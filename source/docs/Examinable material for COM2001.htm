<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 15 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:"Calibri Light";
	panose-1:2 15 3 2 2 2 4 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:0cm;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
h1
	{mso-style-link:"Heading 1 Char";
	margin-top:18.0pt;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:21.6pt;
	text-indent:-21.6pt;
	line-height:107%;
	page-break-after:avoid;
	border:none;
	padding:0cm;
	font-size:18.0pt;
	font-family:"Calibri Light","sans-serif";
	font-variant:small-caps;
	color:black;}
h2
	{mso-style-link:"Heading 2 Char";
	margin-top:18.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:28.8pt;
	margin-bottom:.0001pt;
	text-indent:-28.8pt;
	line-height:107%;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Calibri Light","sans-serif";
	font-variant:small-caps;
	color:black;}
h3
	{mso-style-link:"Heading 3 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	margin-bottom:.0001pt;
	text-indent:-36.0pt;
	line-height:107%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Calibri Light","sans-serif";
	color:black;}
h4
	{mso-style-link:"Heading 4 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:43.2pt;
	margin-bottom:.0001pt;
	text-indent:-43.2pt;
	line-height:107%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Calibri Light","sans-serif";
	color:black;
	font-style:italic;}
h5
	{mso-style-link:"Heading 5 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:50.4pt;
	margin-bottom:.0001pt;
	text-indent:-50.4pt;
	line-height:107%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Calibri Light","sans-serif";
	color:#323E4F;
	font-weight:normal;}
h6
	{mso-style-link:"Heading 6 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:57.6pt;
	margin-bottom:.0001pt;
	text-indent:-57.6pt;
	line-height:107%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Calibri Light","sans-serif";
	color:#323E4F;
	font-weight:normal;
	font-style:italic;}
p.MsoHeading7, li.MsoHeading7, div.MsoHeading7
	{mso-style-link:"Heading 7 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:64.8pt;
	margin-bottom:.0001pt;
	text-indent:-64.8pt;
	line-height:107%;
	page-break-after:avoid;
	font-size:11.0pt;
	font-family:"Calibri Light","sans-serif";
	color:#404040;
	font-style:italic;}
p.MsoHeading8, li.MsoHeading8, div.MsoHeading8
	{mso-style-link:"Heading 8 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:72.0pt;
	margin-bottom:.0001pt;
	text-indent:-72.0pt;
	line-height:107%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Calibri Light","sans-serif";
	color:#404040;}
p.MsoHeading9, li.MsoHeading9, div.MsoHeading9
	{mso-style-link:"Heading 9 Char";
	margin-top:10.0pt;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:79.2pt;
	margin-bottom:.0001pt;
	text-indent:-79.2pt;
	line-height:107%;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Calibri Light","sans-serif";
	color:#404040;
	font-style:italic;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-link:"Header Char";
	margin:0cm;
	margin-bottom:.0001pt;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-link:"Footer Char";
	margin:0cm;
	margin-bottom:.0001pt;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoCaption, li.MsoCaption, div.MsoCaption
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:10.0pt;
	margin-left:0cm;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";
	color:#44546A;
	font-style:italic;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-link:"Title Char";
	margin:0cm;
	margin-bottom:.0001pt;
	font-size:28.0pt;
	font-family:"Calibri Light","sans-serif";
	color:black;}
p.MsoTitleCxSpFirst, li.MsoTitleCxSpFirst, div.MsoTitleCxSpFirst
	{mso-style-link:"Title Char";
	margin:0cm;
	margin-bottom:.0001pt;
	font-size:28.0pt;
	font-family:"Calibri Light","sans-serif";
	color:black;}
p.MsoTitleCxSpMiddle, li.MsoTitleCxSpMiddle, div.MsoTitleCxSpMiddle
	{mso-style-link:"Title Char";
	margin:0cm;
	margin-bottom:.0001pt;
	font-size:28.0pt;
	font-family:"Calibri Light","sans-serif";
	color:black;}
p.MsoTitleCxSpLast, li.MsoTitleCxSpLast, div.MsoTitleCxSpLast
	{mso-style-link:"Title Char";
	margin:0cm;
	margin-bottom:.0001pt;
	font-size:28.0pt;
	font-family:"Calibri Light","sans-serif";
	color:black;}
p.MsoSubtitle, li.MsoSubtitle, div.MsoSubtitle
	{mso-style-link:"Subtitle Char";
	margin-top:0cm;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:0cm;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	color:#5A5A5A;
	letter-spacing:.5pt;}
a:link, span.MsoHyperlink
	{color:#0563C1;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:#954F72;
	text-decoration:underline;}
strong
	{color:black;}
em
	{color:windowtext;}
span.MsoPlaceholderText
	{color:gray;}
p.MsoNoSpacing, li.MsoNoSpacing, div.MsoNoSpacing
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:36.0pt;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	margin-bottom:.0001pt;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:36.0pt;
	margin-bottom:.0001pt;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:36.0pt;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoQuote, li.MsoQuote, div.MsoQuote
	{mso-style-link:"Quote Char";
	margin-top:8.0pt;
	margin-right:36.0pt;
	margin-bottom:8.0pt;
	margin-left:36.0pt;
	line-height:107%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	color:black;
	font-style:italic;}
p.MsoIntenseQuote, li.MsoIntenseQuote, div.MsoIntenseQuote
	{mso-style-link:"Intense Quote Char";
	margin-top:12.0pt;
	margin-right:46.8pt;
	margin-bottom:12.0pt;
	margin-left:46.8pt;
	text-align:center;
	line-height:107%;
	background:#F2F2F2;
	border:none;
	padding:0cm;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	color:black;}
span.MsoSubtleEmphasis
	{color:#404040;
	font-style:italic;}
span.MsoIntenseEmphasis
	{text-transform:uppercase;
	font-weight:bold;
	font-style:italic;}
span.MsoSubtleReference
	{font-variant:small-caps;
	color:#404040;
	text-decoration:underline;}
span.MsoIntenseReference
	{font-variant:small-caps;
	font-weight:bold;
	text-decoration:underline;}
span.MsoBookTitle
	{font-variant:small-caps;
	letter-spacing:.25pt;
	font-weight:normal;}
p.MsoTocHeading, li.MsoTocHeading, div.MsoTocHeading
	{margin-top:18.0pt;
	margin-right:0cm;
	margin-bottom:8.0pt;
	margin-left:21.6pt;
	text-indent:-21.6pt;
	line-height:107%;
	page-break-after:avoid;
	border:none;
	padding:0cm;
	font-size:18.0pt;
	font-family:"Calibri Light","sans-serif";
	font-variant:small-caps;
	color:black;
	font-weight:bold;}
span.Heading1Char
	{mso-style-name:"Heading 1 Char";
	mso-style-link:"Heading 1";
	font-family:"Calibri Light","sans-serif";
	font-variant:small-caps;
	color:black;
	font-weight:bold;}
span.Heading2Char
	{mso-style-name:"Heading 2 Char";
	mso-style-link:"Heading 2";
	font-family:"Calibri Light","sans-serif";
	font-variant:small-caps;
	color:black;
	font-weight:bold;}
span.Heading3Char
	{mso-style-name:"Heading 3 Char";
	mso-style-link:"Heading 3";
	font-family:"Calibri Light","sans-serif";
	color:black;
	font-weight:bold;}
span.Heading4Char
	{mso-style-name:"Heading 4 Char";
	mso-style-link:"Heading 4";
	font-family:"Calibri Light","sans-serif";
	color:black;
	font-weight:bold;
	font-style:italic;}
span.Heading5Char
	{mso-style-name:"Heading 5 Char";
	mso-style-link:"Heading 5";
	font-family:"Calibri Light","sans-serif";
	color:#323E4F;}
span.Heading6Char
	{mso-style-name:"Heading 6 Char";
	mso-style-link:"Heading 6";
	font-family:"Calibri Light","sans-serif";
	color:#323E4F;
	font-style:italic;}
span.Heading7Char
	{mso-style-name:"Heading 7 Char";
	mso-style-link:"Heading 7";
	font-family:"Calibri Light","sans-serif";
	color:#404040;
	font-style:italic;}
span.Heading8Char
	{mso-style-name:"Heading 8 Char";
	mso-style-link:"Heading 8";
	font-family:"Calibri Light","sans-serif";
	color:#404040;}
span.Heading9Char
	{mso-style-name:"Heading 9 Char";
	mso-style-link:"Heading 9";
	font-family:"Calibri Light","sans-serif";
	color:#404040;
	font-style:italic;}
span.TitleChar
	{mso-style-name:"Title Char";
	mso-style-link:Title;
	font-family:"Calibri Light","sans-serif";
	color:black;}
span.SubtitleChar
	{mso-style-name:"Subtitle Char";
	mso-style-link:Subtitle;
	color:#5A5A5A;
	letter-spacing:.5pt;}
span.QuoteChar
	{mso-style-name:"Quote Char";
	mso-style-link:Quote;
	color:black;
	font-style:italic;}
span.IntenseQuoteChar
	{mso-style-name:"Intense Quote Char";
	mso-style-link:"Intense Quote";
	color:black;
	background:#F2F2F2;}
span.HeaderChar
	{mso-style-name:"Header Char";
	mso-style-link:Header;}
span.FooterChar
	{mso-style-name:"Footer Char";
	mso-style-link:Footer;}
.MsoChpDefault
	{font-family:"Calibri","sans-serif";}
.MsoPapDefault
	{margin-bottom:8.0pt;
	line-height:107%;}
 /* Page Definitions */
 @page WordSection1
	{size:595.3pt 841.9pt;
	margin:72.0pt 72.0pt 72.0pt 72.0pt;}
div.WordSection1
	{page:WordSection1;
	width: 750px;
	margin-left: auto;
	margin-right: auto}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=EN-GB link="#0563C1" vlink="#954F72">

<div class=WordSection1>

<p class=MsoTitle><b>Examinable material</b> for COM2001: Advanced Programming
Techniques – James Marshall</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>This document is intended to cover all the examinable
material for the COM2001 second semester exam, as specified in the following
table: </p>

<p class=MsoNormal>Original here: <a
href="http://staffwww.dcs.shef.ac.uk/people/J.Marshall/apt/assignments/exam_guide.pdf">http://staffwww.dcs.shef.ac.uk/people/J.Marshall/apt/assignments/exam_guide.pdf</a> 
</p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=37 valign=top style='width:28.1pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'><b>1</b></p>
  </td>
  <td width=564 valign=top style='width:422.7pt;border:solid windowtext 1.0pt;
  border-left:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to write evaluation traces for recursive functions </p>
  </td>
 </tr>
 <tr style='height:34.9pt'>
  <td width=37 valign=top style='width:28.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt;height:34.9pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'><b>2</b></p>
  </td>
  <td width=564 valign=top style='width:422.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt;height:34.9pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to work with asymptotic complexity notations </p>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• Definition of worst-case vs average-case complexity </p>
  </td>
 </tr>
 <tr style='height:27.35pt'>
  <td width=37 valign=top style='width:28.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt;height:27.35pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'><b>3</b></p>
  </td>
  <td width=564 valign=top style='width:422.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt;height:27.35pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to design divide-and-conquer algorithms </p>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to use recurrence trees </p>
  </td>
 </tr>
 <tr style='height:42.2pt'>
  <td width=37 valign=top style='width:28.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt;height:42.2pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'><b>4</b></p>
  </td>
  <td width=564 valign=top style='width:422.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt;height:42.2pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to solve arithmetic series </p>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to solve geometric series </p>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to analyse algorithms with the Master Theorem </p>
  </td>
 </tr>
 <tr style='height:26.85pt'>
  <td width=37 valign=top style='width:28.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt;height:26.85pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'><b>5</b></p>
  </td>
  <td width=564 valign=top style='width:422.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt;height:26.85pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• Definition of defined and undefined values </p>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to use proof by induction (standard) </p>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to use proof by induction (structural) </p>
  </td>
 </tr>
 <tr style='height:29.2pt'>
  <td width=37 valign=top style='width:28.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt;height:29.2pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'><b>6</b></p>
  </td>
  <td width=564 valign=top style='width:422.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt;height:29.2pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to use proof by induction (strong) </p>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to use proof by induction in imperative languages </p>
  </td>
 </tr>
 <tr style='height:28.2pt'>
  <td width=37 valign=top style='width:28.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt;height:28.2pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'><b>7</b></p>
  </td>
  <td width=564 valign=top style='width:422.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt;height:28.2pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to work with axiomatic specifications of abstract data types </p>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to implement abstract data types in Haskell </p>
  </td>
 </tr>
 <tr>
  <td width=37 valign=top style='width:28.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'><b>8</b></p>
  </td>
  <td width=564 valign=top style='width:422.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• How to show completeness of abstract data type specifications </p>
  </td>
 </tr>
 <tr>
  <td width=37 valign=top style='width:28.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'><b>9</b></p>
  </td>
  <td width=564 valign=top style='width:422.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>• Definition of problems efficiently solvable by dynamic programming </p>
  </td>
 </tr>
</table>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<span style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><br
clear=all style='page-break-before:always'>
</span>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:solid #595959 1.0pt;padding:0cm 0cm 1.0pt 0cm'>

<h1><span style='font-variant:normal !important;text-transform:uppercase'>1<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Evaluation
Traces for Recursive Functions (see section 3.2)</span></h1>

</div>

<p class=MsoNormal>The evaluation trace of a recursive function is the sequence
of steps taken to evaluate a recursive function. At each step, the problem is
split into smaller problems of the same type. Evaluating an expression means
expanding it into the combination of smaller problems. For example evaluating <b>Fib(4)
-&gt; Fib(3) + Fib(2)</b> etc. as in <i>section 3.2.</i></p>

<i><span style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><br
clear=all style='page-break-before:always'>
</span></i>

<p class=MsoNormal><i>&nbsp;</i></p>

<div style='border:none;border-bottom:solid #595959 1.0pt;padding:0cm 0cm 1.0pt 0cm'>

<h1><span style='font-variant:normal !important;text-transform:uppercase'>2<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Complexity</span></h1>

</div>

<p class=MsoNormal>The Time-Complexity of an algorithm tells us the<b> running time</b>
of an algorithm <b>as a function of the input size </b>to the algorithm.</p>

<p class=MsoNormal>Here are graphs of some possible time complexity functions<sup>
[1]</sup>:</p>

<p class=MsoNormal><img border=0 width=459 height=327 id="Picture 1"
src="Examinable%20material%20for%20COM2001_files/image001.jpg"
alt="http://science.slc.edu/~jmarshall/courses/2002/spring/cs50/BigO/running-times.gif"></p>

<p class=MsoNormal>‘Asymptotic’ means the <i>actual </i>running time isn’t
necessarily known, but we do know an ‘asymptote’ of the running time. Which
means we have an estimation for the running time which gets more accurate/relevant
with larger input sizes. </p>

<p class=MsoNormal>An upper/lower bound gives us a maximum/minimum running time
for an algorithm, again only for sufficiently large inputs. For example an
algorithm with input size <b>N </b>could - for sufficiently large <b>N</b> -<b>
</b>always run <i>faster (i.e. in less time) </i>than <b>2<sup>N</sup>. </b>This
would be an upper bound of <b>2<sup>N</sup></b> to the time complexity of the
algorithm.</p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>2.1<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Syntax for
Upper and Lower Bounds</span></h2>

<p class=MsoNormal>When specifying the time complexity of an algorithm, we use <b>Big-O
notation</b> (or big-omega, big-theta).</p>

<p class=MsoNormal><b>O(log(n)) </b>means <b>log(n)</b> is the <i>asymptotic
upper bound</i> for the <i>time complexity</i> of an algorithm with<b>
input-size</b> <b>n</b>. </p>

<p class=MsoNormal><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=220 height=30
src="Examinable%20material%20for%20COM2001_files/image002.png"></span></p>

<p class=MsoNormal><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=217 height=30
src="Examinable%20material%20for%20COM2001_files/image003.png"></span></p>

<p class=MsoNormal><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=309 height=30
src="Examinable%20material%20for%20COM2001_files/image004.png"></span></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The function on the inside of the big-O notation should only
contain the <i>highest order term </i>within the time complexity. For example,
rather than writing <b>O(2n + 3) </b>you should write <b>O(n)</b>, and rather
than writing <b>O(2n<sup>2</sup> + 100n + 9)</b> you should write <b>O(n<sup>2</sup>).
</b>Note that we have to remove both lower order terms and any constant multiples
of the highest order terms, for example we got rid of <b>+ 9</b>, <b>+ 100n</b>
and the <b>2 *</b> multiple of <b>n<sup>2</sup></b>.</p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>2.2<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Complexity
Classes</span></h2>

<p class=MsoNormal>Strictly <b>O(f(n)) </b>refers to a <i>complexity class. </i>This
is the set of functions that have <b>f(n)</b> as a valid upper bound. We
therefore use set notation to talk about complexities. A good illustration of
this is from the mock assignment:</p>

<p class=MsoNormal><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=391 height=19
src="Examinable%20material%20for%20COM2001_files/image005.png"></span></p>

<p class=MsoNormal>The complexity classes to the left are <i>subsets </i>of the
complexity classes to the right, because a larger upper bound is still a valid
upper bound to a function that could have a lower one. i.e. <b>f(n) = 2<sup>n</sup></b>
is a valid upper bound for <b>f(n) = n</b>, which is also a valid upper bound
for <b>f(n) = 1. </b>The opposite of this is true if we were talking about <i>lower
bounds</i><b>.</b></p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>2.3<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Worst Case vs
Average Case</span></h2>

<p class=MsoNormal>The worst case is simple: it’s the time complexity for the
input which takes the longest time. For example for a sorting algorithm taking
an input of 1000 integers, it might take no time at all if the list is already
sorted. The worst case running time for an input of 1000 integers would be if
the integers were ordered such that no other ordering would take a longer time
to sort with that algorithm.</p>

<p class=MsoNormal>The average case is more difficult, as it requires knowledge
about the expected input. To work out the average case, work out the time
complexity for the different inputs, and average these times while weighting
them for their expected probability of occurrence. </p>

<span style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><br
clear=all style='page-break-before:always'>
</span>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:solid #595959 1.0pt;padding:0cm 0cm 1.0pt 0cm'>

<h1><span style='font-variant:normal !important;text-transform:uppercase'>3<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Divide and
Conquer, Recurrence</span></h1>

</div>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>3.1<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Divide and
Conquer </span></h2>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>A divide and conquer algorithm is one that solves a problem
in the following way:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Split
the problem into a few <i>smaller &amp; simpler </i>sub-problems.</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Solve
each of the sub-problems in turn.</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Combine
the results to find the solution to the original problem.</p>

<p class=MsoNormal>It is crucial that the sub-problems are in some way easier
to solve, otherwise the technique is pointless. For example we can write an
algorithm to calculate factorials like follows:</p>

<p class=MsoNormal><b>1! = 1</b></p>

<p class=MsoNormal>and</p>

<p class=MsoNormal><b>N! = (N + 1)! / (N + 1)     </b><i>written in terms of
the factorial above</i></p>

<p class=MsoNormal>Or </p>

<p class=MsoNormal><b>N! = (N – 1)! * N               </b><i>written in terms
of the factorial below</i></p>

<p class=MsoNormal>They’re both correct, but computing the factorial above is
harder than computing the factorial below, so the second algorithm is the only
one that would be useful.</p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>3.2<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Recurrence and
Recurrence Trees</span></h2>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><b>If the sub-problems are of <i>exactly the same type </i>as
the original problem, then the result will be a recursive algorithm. I.e. an
algorithm which is defined in terms of itself.</b></p>

<p class=MsoNormal>The above factorial definition only uses one instance of
itself in its definition. Iteratively expanding the definition for <b>5! </b>Would
look as follows:</p>

<p class=MsoNormal align=center style='text-align:center'><i>5!</i></p>

<p class=MsoNormal align=center style='text-align:center'><i>4! * 5</i></p>

<p class=MsoNormal align=center style='text-align:center'><i>3! * 4 * 5</i></p>

<p class=MsoNormal align=center style='text-align:center'><i>2! * 3 * 4 * 5</i></p>

<p class=MsoNormal align=center style='text-align:center'><i>1! * 2 * 3 * 4 * 5</i></p>

<p class=MsoNormal align=center style='text-align:center'><i>1 * 2 * 3 * 4 * 5</i></p>

<p class=MsoNormal>The second classic example of recursion is the Fibonacci
sequence:</p>

<p class=MsoNormal><b>Fib(N) = Fib(N – 1) + Fib(N – 2)</b></p>

<p class=MsoNormal><b>Fib(1) and Fib(2) = 1</b></p>

<p class=MsoNormal>Iteratively expanding <b>Fib(5) </b>would look as follows:</p>

<p class=MsoNormal align=center style='text-align:center'><i>Fib (5)</i></p>

<p class=MsoNormal align=center style='text-align:center'><i>Fib(4) + Fib(3)</i></p>

<p class=MsoNormal align=center style='text-align:center'><i>(Fib(3) + Fib(2))
+ (Fib(2) + Fib(1))</i></p>

<p class=MsoNormal align=center style='text-align:center'><i>((Fib(2) + Fib(1))
+ 1) + (1 + 1)</i></p>

<p class=MsoNormal align=center style='text-align:center'><i>((1 + 1) + 1) + (1
+ 1)</i></p>

<p class=MsoNormal>This is called the recurrence tree. The number of times the
tree branches at each node is the number of smaller sub-problems the divide and
conquer approach has used, and is the number of recurrences at each stage.
Recurrence trees may best be drawn as actual trees with lines connecting
successive expansions, as in the following image<sup> [2]</sup>:</p>

<p class=MsoNormal><img border=0 width=492 height=381 id="Picture 2"
src="Examinable%20material%20for%20COM2001_files/image006.png"
alt="http://blog.marquiswang.com/wp-content/uploads/2010/02/Untitled.png"></p>

<span style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><br
clear=all style='page-break-before:always'>
</span>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:solid #595959 1.0pt;padding:0cm 0cm 1.0pt 0cm'>

<h1><span style='font-variant:normal !important;text-transform:uppercase'>4<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Summing Finite
Series and the Master Theorem</span></h1>

</div>

<p class=MsoNormal>This section explains how to calculate the asymptotic time
complexity of recursive algorithms using the “Master Theorem” or summing of
finite series.</p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>4.1<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Summing Arithmetic
Series</span></h2>

<p class=MsoNormal>An Arithmetic sequence is a sequence of numbers where each
number is a constant number larger than the previous. For example <b>2, 5, 8,
11, 14</b> … each number is <b>+3</b> larger than the last.</p>

<p class=MsoNormal>The <i>closed-form </i>solution for summing a finite number
of terms in an arithmetic series is:</p>

<p class=MsoNormal><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=69 height=35
src="Examinable%20material%20for%20COM2001_files/image007.png"></span></p>

<p class=MsoNormal>Where <b>n</b> is the number of terms being added, <b>a<sub>1</sub></b><sub>
</sub>is the first term and <b>a<sub>n </sub></b>is the last term. For the
sequence <b>2, 5, 8, 11, 14</b> the answer would be <b>5 * (2 + 14) / 2 = 40</b></p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>4.2<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Summing Geometric
Series</span></h2>

<p class=MsoNormal>A Geometric sequence is a sequence where each term is a
constant multiple of the previous, for example <b>1, 2, 4, 8, 16, 32 </b>… each
number is <b>twice as large</b> as the last.</p>

<p class=MsoNormal>The closed-form solution for summing a finite number of
terms in a geometric series is:</p>

<p class=MsoNormal><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=59 height=35
src="Examinable%20material%20for%20COM2001_files/image008.png"></span></p>

<p class=MsoNormal>Where <b>n</b> is the number of terms, <b>x</b> is the ratio
between successive terms, and <b>a<sub>1 </sub></b>is the first term. For the
sequence <b>4, 12, 36, 108 </b>the answer would be <b>4 * (3^4 – 1) / (3 – 1) =
160. </b></p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>4.3<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Using series
for finding Time-Complexity</span></h2>

<p class=MsoNormal>When the running time for an algorithm can be specified as a
summation of terms (see 2d and 2e in the mock assignment) the formulas above
can be used to find the closed form solution for the time complexity, which can
then be simplified into <b>Big-O</b> notation.</p>

<span style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><br
clear=all style='page-break-before:always'>
</span>

<p class=MsoNormal>&nbsp;</p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>4.4<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>The Master
Theorem</span></h2>

<p class=MsoNormal>The master theorem is a ‘cookbook’ method for finding the
time complexity of an algorithm. This means it <i>should</i> be usable without
any understanding of why it works.</p>

<p class=MsoNormal>If a function has time complexity <b>T(n)</b> …</p>

<p class=MsoNormal><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=145 height=32
src="Examinable%20material%20for%20COM2001_files/image009.png"></span></p>

<p class=MsoNormal>Meaning at each stage, the problem (size <b>n</b>) is split
into <b>a</b> parts, each of size <b>n/b</b> which are each solved with a time
complexity of <b>T(n/b) </b>and<b> </b>combined with a cost of <b>f(n)</b>. So <b>a*T(n/b)</b>
is the time taken to solve all the sub-problems, and <b>f(n)</b> is the extra
work needed to split the problem down and put the solutions back together.</p>

<p class=MsoNormal>The diagram below<sup> [3]</sup> shows a general breakdown
of the time complexity of an algorithm given the equation above. There are a couple
of important things to note:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Each
terminating node (leaf) in the recursion tree is completed in constant <b>O(1) </b>time,
and there are <b>n^log<sub>b</sub>(a) </b>of them, meaning the leaves together
contribute <b>O(n^log<sub>b</sub>(a)) </b>time.</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>The
summation of all the <b>f(n)</b>’s from the rest of the nodes (down the right
hand side of the diagram) add up to make the rest of the formula, as you can
see in the bottom right of the diagram.</p>

<p class=MsoNormal><img border=0 width=634 height=409 id="Picture 3"
src="Examinable%20material%20for%20COM2001_files/image010.png"></p>

<span style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><br
clear=all style='page-break-before:always'>
</span>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The Master theorem looks at the values for <b>a</b>, <b>b</b>
and <b>f(n)</b> and derives which part of this general equation is the highest
order part – i.e. which part is most significant as <b>n</b> becomes large.
There are three possibilities:</p>

<p class=MsoListParagraphCxSpFirst align=center style='margin-left:18.0pt;
text-align:center;text-indent:-18.0pt'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Most of the work is done at the leaves when <b>n</b> is large. This
means the algorithm has complexity: </p>

<p class=MsoListParagraphCxSpLast><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=101 height=31
src="Examinable%20material%20for%20COM2001_files/image011.png"></span></p>

<p class=MsoNormal>       This is always the case if:</p>

<p class=MsoListParagraph align=center style='text-align:center'><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=209 height=31
src="Examinable%20material%20for%20COM2001_files/image012.png"></span></p>

<p class=MsoNormal style='margin-left:18.0pt'>Where &#949; is some positive
constant. This means the time complexity of <b>f(n)</b> is polynomially smaller
than the time complexity of all the work done at the leaves.</p>

<p class=MsoListParagraphCxSpFirst>&nbsp;</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:18.0pt;text-indent:-18.0pt'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>The
work done at the leaves and at each node have similar time-complexities (i.e.
neither the leaves nor nodes completely dominate the running time for
sufficiently large <b>n</b>). In this case the time complexity is:</p>

<p class=MsoListParagraphCxSpMiddle align=center style='margin-left:18.0pt;
text-align:center'><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=164 height=32
src="Examinable%20material%20for%20COM2001_files/image013.png"></span></p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:18.0pt'>This is always the
case if:</p>

<p class=MsoListParagraphCxSpLast align=center style='text-align:center'><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=180 height=31
src="Examinable%20material%20for%20COM2001_files/image014.png"></span></p>

<p class=MsoNormal>       This means that <b>f(n)</b> has the same time
complexity as the work done at the leaves.</p>

<p class=MsoListParagraphCxSpFirst style='margin-left:18.0pt'>&nbsp;</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:18.0pt;text-indent:-18.0pt'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>The
work done at the <b>root </b>dominates as <b>n</b> becomes large. Time
complexity is:</p>

<p class=MsoListParagraphCxSpMiddle align=center style='margin-left:18.0pt;
text-align:center'><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><img
width=85 height=30
src="Examinable%20material%20for%20COM2001_files/image015.png"></span></p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:18.0pt'>This is always the
case if both: </p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:18.0pt'>&nbsp;</p>

<p class=MsoListParagraphCxSpMiddle align=center style='text-align:center'><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif";
position:relative;top:6.0pt'><img width=209 height=31
src="Examinable%20material%20for%20COM2001_files/image016.png"></span><span
style='font-size:18.0pt;line-height:107%'> </span></p>

<p class=MsoListParagraphCxSpMiddle align=center style='text-align:center'><i>and</i></p>

<p class=MsoListParagraphCxSpLast align=center style='text-align:center'><span
style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif";
position:relative;top:11.5pt'><img width=213 height=45
src="Examinable%20material%20for%20COM2001_files/image017.png"></span><span
style='font-size:18.0pt;line-height:107%'> </span></p>

<p class=MsoNormal style='margin-left:21.6pt'>For some constant <b>c &lt; 1</b>,
some positive constant &#949; and<b> </b>for sufficiently large<b> n</b>. This
means two things: That the work done at the nodes will dominate over the work
done at the leaves, and that the work done at the root node will dominate over
the work done at all the other nodes.</p>

<p class=MsoNormal style='margin-left:21.6pt'>&nbsp;</p>

<p class=MsoNormal>To apply the master theorem, just find values for <b>a</b>, <b>b</b>
and <b>f(n)</b> and check which of the conditions hold from 1, 2 or 3. Once you
have found this, the time complexity of the algorithm is known. If none of the
conditions hold, or the algorithm’s running time can’t be written in terms of <b>a</b>,
<b>b</b> and <b>f(n)</b>, the master theorem doesn’t apply. See answers to
parts <b>3a – 3i</b> in the mock assessment for examples.    </p>

<p class=MsoListParagraph style='margin-left:18.0pt'>&nbsp;</p>

<span style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><br
clear=all style='page-break-before:always'>
</span>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:solid #595959 1.0pt;padding:0cm 0cm 1.0pt 0cm'>

<h1><span style='font-variant:normal !important;text-transform:uppercase'>5<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Proof by
Induction (standard and structural)</span></h1>

</div>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>5.1<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Defined and
Undefined Results for Recursive Functions</span></h2>

<p class=MsoNormal>For a recursive Haskell function, the result of calling a
function is defined if the recursion will terminate at some point and return a
result. The value is undefined if the recursion continues for ever, for example
see the recursive definitions of factorial given in <b>3.2</b> of this
document.</p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>5.2<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>What is
standard/structural induction?</span></h2>

<p class=MsoNormal><i>Standard</i> <i>induction</i> proves that some property
holds over all the natural numbers. For example if we can prove that <b>P(0)</b>
holds, and <b>P(n) =&gt; P(n + 1)</b> for all <b>n</b>, we have proved that <b>P(n)</b>
holds for all natural numbers <b>n</b>.</p>

<p class=MsoNormal><i>Structural induction</i> does the same, but for lists of
length <b>n</b>. If we can prove that <b>P( [] )</b> holds, and <b>P(t) =&gt;
P(h:t)</b> for all lists <b>t</b> and elements <b>h</b>, we have proved that <b>P(lst)</b>
holds for all lists <b>lst</b>.</p>

<p class=MsoNormal>Proofs using induction (standard and structural) should be
formatted as follows:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><b>Proof
outline:</b> State your proof goal, base case and induction stage clearly in
Haskell syntax, labelling them as such. </p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><b>Prove
base case:</b> Usually the base case will be the same as the final proof goal,
but with some variable substituted with <b>0</b> (for standard induction) or <b>[]</b>
(for structural induction).</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><b>Prove
the induction case:</b> In this part, you can assume the property holds for <b>n</b>
and you must show it holds for <b>n + 1 </b>(or some list <b>x</b> and then <b>h:x</b>
for structural induction).</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><b>State
clearly that these three proofs together prove that P(x) holds for all x. QED.</b></p>

<p class=MsoNormal>At each stage (1, 2 and 3) the proof is completed by showing
that the left and right hand side of the equations are equal by iteratively substituting
and manipulating them using the supplied Haskell code. At each substitution,
you should label the line with the substitution you’ve used (for example <b>++.1</b>
or <b>reverse.2</b>).</p>

<p class=MsoNormal>There is a very thorough and helpful guide on all of this,
with lots of examples, in <b>Chapter 8 of Haskell – The craft of functional
programming</b>. Available in the IC and St. George’s. </p>

<span style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><br
clear=all style='page-break-before:always'>
</span>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:solid #595959 1.0pt;padding:0cm 0cm 1.0pt 0cm'>

<h1><span style='font-variant:normal !important;text-transform:uppercase'>6<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Strong
Induction and Imperative Proof</span></h1>

</div>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>6.1<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Strong
Induction</span></h2>

<p class=MsoNormal>In standard induction, the induction step proves that <b>P(n)
implies P(n + 1) </b>for all <b>n</b>. Sometimes assuming <b>P(n)</b> is not
enough to prove <b>P(n + 1)</b>.</p>

<p class=MsoNormal>Strong induction assumes <b>P(n)</b> is true along with <b>P(n
– 1), P(n – 2)</b> and <b>P of</b> <b>all values between 0 and n</b>. So with
strong induction we show that <b>(P(K) for all 0 &lt;= K &lt;= n) implies P(n +
1). </b></p>

<p class=MsoNormal>Strong induction, despite its name, is just as powerful as
weak induction. There is nothing that can be proven with the strong version
that can’t be proven with the weak version. However using strong induction
allows for more concise proofs for things like the Fibonacci sequence where the
definition of <b>Fib(n)</b> includes <b>Fib(n – 2)</b> and not just <b>Fib(n –
1)</b>.</p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>6.2<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Imperative
proofs – loop invariants</span></h2>

<p class=MsoNormal>Imperative programs are programs written as a sequence of
steps. Most common languages are imperative at their core, i.e. javascript/java/ruby
etc. although they may have ‘functional’ type features.</p>

<p class=MsoNormal>In Marshall’s notes, he gives one example of proving an
imperative program correct, and it is proven informally on a pseudo-code implementation
of insertion sort. This example is paraphrased from chapter 2 of CLRS.</p>

<p class=MsoNormal>Proofs that an imperative program works need to show that
some <i>invariant</i> holds throughout the running time of the algorithm/loop.
The invariant, by the time the loop or program terminates, should be some
desirable characteristic, for example that a list is sorted.</p>

<p class=MsoNormal>Structure your imperative proofs as follows:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><b>State
the loop invariant: </b>This is some property of the <i>state </i>of the
program that you want to remain true throughout its running. This might be
given to you in the question.</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><b>Initialisation:</b>
Show that the property is true before the program or loop has started running.
This should be trivial; just look at what the invariant applies to at the
beginning of the program (maybe an empty list, or the number 0 etc.) and show
that it is true.</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-18.0pt'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><b>Maintenance:
</b>Prove that the contents of the loop will not make the invariant false if it
is true at the start of the loop. I.e. true at start =&gt; true at end.</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><b>Termination:
</b>State how the loop invariant, which is still true due to the above two
conditions, shows your program’s correctness at termination. The example in the
notes states that the loop invariant is a sorted sub-list of the input list,
which at the point of program termination is the whole input list, now completely
sorted.</p>

<p class=MsoNormal>For a couple more examples of informal proofs of imperative
programs, see <b>chapter 2 of CLRS</b>.</p>

<p class=MsoNormal>Mike Stannet’s notes introduce <b>Floyd–Hoare logic </b>which
is a more formal logical system for proving correctness of imperative programs,
although this isn’t mentioned in Marshal’s notes. Any question about imperative
proof will probably require an informal proof.</p>

<span style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><br
clear=all style='page-break-before:always'>
</span>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:solid #595959 1.0pt;padding:0cm 0cm 1.0pt 0cm'>

<h1><span style='font-variant:normal !important;text-transform:uppercase'>7<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Axiomatic
Specifications and Abstract Data Types</span></h1>

</div>

<h2><span style='font-size:18.0pt;line-height:107%;font-variant:normal !important;
text-transform:uppercase'>7.1<span style='font:7.0pt "Times New Roman"'>&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Abstract Data
Types</span></h2>

<p class=MsoNormal>Abstract Data Types (ADTs) are a concept in computer science
independent of any language. There are no ‘ADT’ keywords or constructs within
Haskell. Instead it is said that an ADT (usually some mathematical model of a
data structure) can be implemented in Haskell using <b>modules</b>, which <i>are</i>
a specific Haskell structure. It is said that Haskell modules allow ADT’s to be
built in Haskell.</p>

<p class=MsoNormal>The characteristic feature of an ADT is that it can (and
should) be used without knowledge of its implementation – this is also called
information hiding/abstraction, as the information about the ADT’s
implementation is hidden/abstracted away from the ADT’s user. Haskell modules
allow this.</p>

<p class=MsoNormal>To start a Haskell module</p>

<p class=MsoNormal><b><span style='font-size:13.5pt;line-height:107%;
font-family:"Courier New";color:black;background:white'>module&nbsp;ModuleName&nbsp;(MemberOne,&nbsp;MemberTwo,&nbsp;MemberThree)</span></b></p>

<p class=MsoNormal><b><span style='font-size:13.5pt;line-height:107%;
font-family:"Courier New";color:black;background:white'>     where </span></b><b><span
style='font-size:13.5pt;line-height:107%;font-family:"Courier New";color:#AEAAAA;
background:white'>-- followed by definitions for each member</span></b></p>

<p class=MsoNormal><span style='background:white'>When ‘ModuleName’ is
imported, we won’t be able to depend on the specific implementation within the
module.</span></p>

<p class=MsoNormal><span style='background:white'>For a couple of examples, see
Marshall’s Set and Stack modules:</span></p>

<p class=MsoNormal><b><span style='background:white'>Stack:</span></b><span
style='background:white'>    </span><a
href="http://staffwww.dcs.shef.ac.uk/people/J.Marshall/apt/haskell/Stack.hs"><span
style='background:white'>http://staffwww.dcs.shef.ac.uk/people/J.Marshall/apt/haskell/Stack.hs</span></a></p>

<p class=MsoNormal><b><span style='background:white'>Set:</span></b><span
style='background:white'>        </span><a
href="http://staffwww.dcs.shef.ac.uk/people/J.Marshall/apt/haskell/Set.hs"><span
style='background:white'>http://staffwww.dcs.shef.ac.uk/people/J.Marshall/apt/haskell/Set.hs</span></a></p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>7.2<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase;background:white'>Axiomatic
Specifications of ADTs</span></h2>

<p class=MsoNormal>An ADT can be specified axiomatically. This specification
will be a collection of relationships between functions which need to hold true
for any implementation. For example, part of the specification of Marshall’s
Stack ADT is:</p>

<p class=MsoNormal><b><span style='font-size:13.5pt;line-height:107%;
font-family:"Courier New"'>isEmpty emptyStack == True <span style='color:#AEAAAA'>--
(specIsEmpty.1)</span></span></b></p>

<p class=MsoNormal><span style='background:white'>Any Haskell implementation of
this Stack ADT must satisfy this condition, and all other axioms.</span></p>

<p class=MsoNormal><span style='background:white'>Remember that these axioms,
although they’re written in Haskell syntax, exist outside any Haskell
implementation. They’re abstract mathematical descriptions of a data structure
that could have many implementations. You may be asked to prove a specific
implementation satisfies a certain collection of axioms. Proving this is
exactly the same as any other proof of program correctness, so see <b>section 5</b>
of this document.</span></p>

<p class=MsoNormal><b>&nbsp;</b></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<span style='font-size:11.0pt;line-height:107%;font-family:"Calibri","sans-serif"'><br
clear=all style='page-break-before:always'>
</span>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:solid #595959 1.0pt;padding:0cm 0cm 1.0pt 0cm'>

<h1><span style='font-variant:normal !important;text-transform:uppercase'>8<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Completeness
and Proofs with ADT’s</span></h1>

</div>

<p class=MsoNormal><i>Completeness, </i>in this context, is a property of the
axiomatic specification of an ADT and <b>not </b>the implementation. It is also
not a <i>formal </i>property, as an axiomatic specification is only complete
relative to an intuitive (i.e. informal) idea of how the ADT should behave. To
say that an axiomatic specification is <i>complete </i>is to say that it aligns
<i>completely </i>with your intuitive understanding, without the need for any
additional axioms.</p>

<p class=MsoNormal>This means an axiomatic specification can be said to be <i>incomplete</i>
if there is a property which cannot be proven/derived from the axioms, but
which still should ‘intuitively’ hold.</p>

<p class=MsoNormal>You will need to use the same methods of proof described in
section 5 to prove that an axiomatic spec is satisfied by a particular
implementation.<i><br clear=all style='page-break-before:always'>
</i></p>

<div style='border:none;border-bottom:solid #595959 1.0pt;padding:0cm 0cm 1.0pt 0cm'>

<h1><span style='font-variant:normal !important;text-transform:uppercase'>9<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Dynamic
Programming</span></h1>

</div>

<p class=MsoNormal>A problem is efficiently solvable with dynamic programming
if it satisfies the following 2 conditions:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-18.0pt'><b>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></b><b>Optimal
Substructure: </b>Finding the optimal solution to the problem involves finding
the optimal solution to some other sub-problems. </p>

<p class=MsoListParagraphCxSpLast style='text-indent:-18.0pt'><b>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></b><b>Overlapping
sub-problems: </b>A solution to a sub-problem can be used by multiple other
problems, and the sub-problems that need to be solved for a specific problem
will share other sub-problems. An example of this is the Fibonacci sequence:
Fib(10) = Fib(9) + Fib(8), and the two sub-problems of Fib(9) and Fib(8)
overlap because they both require working out Fib(7) etc.</p>

<p class=MsoNormal>Together, these two conditions allow memoization to be
effective. Memoization effectively adds a cache to the function, so it doesn’t
solve from scratch a particular sub-problem twice.</p>

<h2><span style='font-variant:normal !important;text-transform:uppercase'>9.1<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp; </span></span><span
style='font-variant:normal !important;text-transform:uppercase'>Sub-problem
Graphs</span></h2>

<p class=MsoNormal>Sub-problem graphs are like recurrence trees but with
memoization, so no sub-problem is worked out twice from scratch. Compare the
following two diagrams for calculating the Fibonacci numbers:</p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=301 valign=top style='width:225.4pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>Simple recurrence (repeated calculations) [3]</p>
  </td>
  <td width=301 valign=top style='width:225.4pt;border:solid windowtext 1.0pt;
  border-left:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'>With dynamic programming (memoization) [4]</p>
  </td>
 </tr>
 <tr>
  <td width=301 valign=top style='width:225.4pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'><img border=0 width=289 height=227 id="Picture 5"
  src="Examinable%20material%20for%20COM2001_files/image018.png"
  alt="http://blog.marquiswang.com/wp-content/uploads/2010/02/Untitled.png"></p>
  </td>
  <td width=301 valign=top style='width:225.4pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal style='margin-bottom:0cm;margin-bottom:.0001pt;line-height:
  normal'><img border=0 width=283 height=167 id="Picture 6"
  src="Examinable%20material%20for%20COM2001_files/image019.png"></p>
  </td>
 </tr>
</table>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>On the left hand side, <b>F(4)</b> is calculated twice, once
on the left and once on the right. On the right hand side (with dynamic
programming) <b>F(4)</b> – or 3 in the diagram – is only calculated once for
all larger Fibonacci numbers. The diagram on the left is a recurrence tree, and
the diagram on the right is a sub-problem graph. <br clear=all
style='page-break-before:always'>
</p>

<div style='border:none;border-bottom:solid #595959 1.0pt;padding:0cm 0cm 1.0pt 0cm'>

<h1><span style='font-variant:normal !important;text-transform:uppercase'>10<span
style='font:7.0pt "Times New Roman"'> </span></span><span style='font-variant:
normal !important;text-transform:uppercase'>References/Sources</span></h1>

</div>

<p class=MsoNormal>[1] Taken from <a
href="http://science.slc.edu/~jmarshall/courses/2002/spring/cs50/BigO/">http://science.slc.edu/~jmarshall/courses/2002/spring/cs50/BigO/</a>
without permission… Yes that course is also taught by a J. Marshall. Shock
horror!</p>

<p class=MsoNormal>[2] Stolen shamelessly from <a
href="http://blog.marquiswang.com/2010/02/20/fibonacci-functions-and-dynamic-programming/">http://blog.marquiswang.com/2010/02/20/fibonacci-functions-and-dynamic-programming/</a>
without permission.</p>

<p class=MsoNormal>[3] Photo taken by me from Introduction to Algorithms (CLRS),
page 77 in 2001 version.</p>

<p class=MsoNormal>[4] Drawn by me in Paint.NET</p>

</div>

</body>

</html>
